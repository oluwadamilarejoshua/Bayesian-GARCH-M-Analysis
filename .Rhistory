library(readxl)
research_data <- read_excel("../Data/Research data.xlsx")
head(research_data)
research_data <- as.data.frame(read_excel("../Data/Research data.xlsx"))
head(research_data)
colnames(research_data) <- c('Year', 'Import', 'Export',
'Debt', 'GDP', 'ExchangeRate')
head(research_data)
library(tidyverse)
data_scaled <- research_data
data_scaled[, c("ExchangeRate", "Import", "Export", "Debt", "GDP")] <-
data[, c("ExchangeRate", "Import", "Export", "Debt", "GDP")] / 1e6
data_scaled[, c("Import", "Export", "Debt", "GDP", "ExchangeRate")] <-
data[, c("Import", "Export", "Debt", "GDP", "ExchangeRate")] / 1e6
library(readxl)
library(tidyverse)
data <- read_excel("Research data.xlsx")
data <- read_excel("../Data/Research data.xlsx")
data_scaled <- data
data_scaled[, c("Imports of goods and services (current US$)",
"Exports of goods and services (current US$)",
"Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)")] <-
data[, c("Imports of goods and services (current US$)",
"Exports of goods and services (current US$)",
"Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)")] / 1e6
data_transformed <- data_scaled
data_transformed[, c("Imports of goods and services (current US$)",
"Exports of goods and services (current US$)",
"Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)",
"Real effective exchange rate index (2010 = 100)")] <-
log(data_scaled[, c("Imports of goods and services (current US$)",
"Exports of goods and services (current US$)",
"Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)",
"Real effective exchange rate index (2010 = 100)")])
# View the transformed data
head(data_transformed)
data_transformed <- as.data.frame(data_transformed)
head(data_transformed)
colnames(data_transformed) <- c('Year', 'Import', 'Export',
'Debt', 'GDP', 'ExchangeRate')
head(data_transformed)
# Assign variables
y <- data_transformed$ExchangeRate
X <- as.matrix(data_transformed[, c("Import", "Export", "Debt", "GDP")])
# Summary of the data
summary(data_transformed)
# Plot y and predictors
pairs(data_transformed[, c("ExchangeRate", "Import", "Export", "Debt", "GDP")])
# Install required package if not already installed
if (!require("GGally")) install.packages("GGally")
# Load libraries
library(ggplot2)
library(GGally)
# Create a subset for plotting
data_subset <- data_transformed[, c("ExchangeRate", "Import", "Export", "Debt", "GDP")]
# Create pair plot using GGally
ggpairs(data_subset,
title = "Pairs Plot of Exchange Rate and Predictors",
progress = FALSE)
# Create pair plot using GGally
ggpairs(data_subset,
title = "Scatter Plots of Exchange Rate and Predictors",
progress = FALSE)
# Preliminary OLS model
ols_model <- lm(y ~ X)
summary(ols_model)
# Extract coefficients and residual variance
ols_coefficients <- coef(ols_model)
ols_variance <- var(residuals(ols_model))
# Priors for beta and mu
prior_mu <- ols_coefficients[1]  # Intercept
prior_beta <- ols_coefficients[-1]  # Coefficients for predictors
prior_variance <- ols_variance  # Prior variance for residuals
log_prior <- function(params) {
mu <- params[1]
gamma <- params[2]
beta_X <- params[3:(2 + ncol(X))]
omega <- params[3 + ncol(X)]
alpha <- params[4 + ncol(X)]
beta <- params[5 + ncol(X)]
# Priors based on empirical evidence
prior_mu <- dnorm(mu, prior_mu, sqrt(prior_variance), log = TRUE)
prior_gamma <- dnorm(gamma, 0, 10, log = TRUE)
prior_beta_X <- sum(dnorm(beta_X, prior_beta, sqrt(prior_variance), log = TRUE))
prior_omega <- ifelse(omega > 0 & omega < 1, 0, -Inf)
prior_alpha <- ifelse(alpha > 0 & alpha < 1, 0, -Inf)
prior_beta <- ifelse(beta > 0 & beta < 1, 0, -Inf)
return(prior_mu + prior_gamma + prior_beta_X + prior_omega + prior_alpha + prior_beta)
}
log_likelihood <- function(params, y, X) {
mu <- params[1]
gamma <- params[2]
beta_X <- params[3:(2 + ncol(X))]
omega <- params[3 + ncol(X)]
alpha <- params[4 + ncol(X)]
beta <- params[5 + ncol(X)]
n <- length(y)
h <- numeric(n)
h[1] <- omega / (1 - alpha - beta)
log_lik <- 0
for (t in 2:n) {
h[t] <- omega + alpha * (y[t-1] - mu - gamma * h[t-1] - sum(X[t-1, ] * beta_X))^2 + beta * h[t-1]
log_lik <- log_lik - 0.5 * (log(2 * pi) + log(h[t]) + (y[t] - mu - gamma * h[t] - sum(X[t, ] * beta_X))^2 / h[t])
}
return(log_lik)
}
log_posterior <- function(params, y, X) {
log_likelihood(params, y, X) + log_prior(params)
}
log_posterior <- function(params, y, X) {
log_likelihood(params, y, X) + log_prior(params)
}
metropolis <- function(init, y, X, n_iter, proposal_sd) {
params <- init
samples <- matrix(NA, nrow = n_iter, ncol = length(init))
accept <- 0
for (i in 1:n_iter) {
proposal <- rnorm(length(init), mean = params, sd = proposal_sd)
log_accept_ratio <- log_posterior(proposal, y, X) - log_posterior(params, y, X)
if (log(runif(1)) < log_accept_ratio) {
params <- proposal
accept <- accept + 1
}
samples[i, ] <- params
}
cat("Acceptance rate:", accept / n_iter, "\n")
return(samples)
}
init <- c(prior_mu, 0.1, rep(0.1, ncol(X)), 0.1, 0.1, 0.1)
# Run MCMC
n_iter <- 5000
proposal_sd <- 0.05
samples <- metropolis(init, y, X, n_iter, proposal_sd)
metropolis <- function(init, y, X, n_iter, proposal_sd) {
params <- init
samples <- matrix(NA, nrow = n_iter, ncol = length(init))
accept <- 0
for (i in 1:n_iter) {
proposal <- rnorm(length(init), mean = params, sd = proposal_sd)
log_accept_ratio <- log_posterior(proposal, y, X) - log_posterior(params, y, X)
# Debugging and safeguard
if (is.na(log_accept_ratio) || is.nan(log_accept_ratio)) {
cat("Invalid log_accept_ratio at iteration", i, "\n")
cat("Proposed Parameters:", proposal, "\n")
cat("Log Posterior (proposal):", log_posterior(proposal, y, X), "\n")
cat("Log Posterior (current):", log_posterior(params, y, X), "\n")
stop("log_accept_ratio is invalid. Check your log_posterior function.")
}
if (log(runif(1)) < log_accept_ratio) {
params <- proposal
accept <- accept + 1
}
samples[i, ] <- params
}
cat("Acceptance rate:", accept / n_iter, "\n")
return(samples)
}
init <- c(prior_mu, 0.1, rep(0.1, ncol(X)), 0.1, 0.1, 0.1)
n_iter <- 5000
proposal_sd <- 0.05
samples <- metropolis(init, y, X, n_iter, proposal_sd)
log_posterior <- function(params, y, X) {
# Extract parameters
beta_0 <- params[1]
beta_X <- params[2:(1 + ncol(X))]
omega <- params[2 + ncol(X)]
alpha <- params[3 + ncol(X)]
beta <- params[4 + ncol(X)]
# Compute the log-prior
log_prior <- 0
if (omega <= 0 || alpha <= 0 || beta <= 0 || (alpha + beta) >= 1) {
return(-Inf)  # Invalid GARCH parameters
}
log_prior <- sum(dnorm(beta_X, mean = 0, sd = 1, log = TRUE)) +
dgamma(omega, shape = 2, rate = 1, log = TRUE) +
dbeta(alpha, 2, 2, log = TRUE) +
dbeta(beta, 2, 2, log = TRUE)
# Compute the log-likelihood
n <- length(y)
h <- numeric(n)
h[1] <- var(y)  # Initialize variance
log_likelihood <- 0
for (t in 2:n) {
h[t] <- omega + alpha * (y[t - 1]^2) + beta * h[t - 1]
if (h[t] <= 0) {
return(-Inf)  # Invalid variance
}
mu_t <- beta_0 + sum(beta_X * X[t, ])
log_likelihood <- log_likelihood + dnorm(y[t], mean = mu_t, sd = sqrt(h[t]), log = TRUE)
}
# Total log-posterior
log_posterior_value <- log_prior + log_likelihood
# Debugging output
cat("Log Prior:", log_prior, "\n")
cat("Log Likelihood:", log_likelihood, "\n")
cat("Log Posterior:", log_posterior_value, "\n")
return(log_posterior_value)
}
samples <- metropolis(init, y, X, n_iter, proposal_sd)
# Posterior means and credible intervals
posterior_means <- colMeans(samples)
credible_intervals <- apply(samples, 2, quantile, probs = c(0.025, 0.975))
# Print results
cat("Posterior Means:\n", posterior_means, "\n")
cat("95% Credible Intervals:\n", credible_intervals, "\n")
# Plot posterior distributions
par(mfrow = c(3, 2))
for (i in 1:ncol(samples)) {
hist(samples[, i], main = paste("Parameter", i), xlab = "Value", probability = TRUE)
}
proposal_sd <- 0.001
samples <- metropolis(init, y, X, n_iter, proposal_sd)
proposal_sd <- 0.01
samples <- metropolis(init, y, X, n_iter, proposal_sd)
proposal_sd <- 0.1
samples <- metropolis(init, y, X, n_iter, proposal_sd)
proposal_sd <- 0.008
samples <- metropolis(init, y, X, n_iter, proposal_sd)
proposal_sd <- 0.005
samples <- metropolis(init, y, X, n_iter, proposal_sd)
n_iter <- 10000
proposal_sd <- 0.01
samples <- metropolis(init, y, X, n_iter, proposal_sd)
n_iter <- 15000
proposal_sd <- 0.01
samples <- metropolis(init, y, X, n_iter, proposal_sd)
n_iter <- 10000
proposal_sd <- 0.01
samples <- metropolis(init, y, X, n_iter, proposal_sd)
proposal_sd <- 0.009
samples <- metropolis(init, y, X, n_iter, proposal_sd)
proposal_sd <- 0.008
samples <- metropolis(init, y, X, n_iter, proposal_sd)
library(coda)
install.packages('coda')
library(coda)
# Convert samples matrix to mcmc object (for analysis with coda)
mcmc_samples <- as.mcmc(samples)
# Plot trace plots for each parameter
par(mfrow=c(2, 2))  # Arrange the plots in a 2x2 grid
plot(mcmc_samples[, 1], main="Trace Plot: Parameter 1")
plot(mcmc_samples[, 2], main="Trace Plot: Parameter 2")
plot(mcmc_samples[, 3], main="Trace Plot: Parameter 3")
plot(mcmc_samples[, 4], main="Trace Plot: Parameter 4")
library(readxl)
library(tidyverse)
library(GGally)
data <- read_excel("../Data/ResearchData.xlsx")
# Scaling the monetary variables by dividing by 1 million
data_scaled <- data
data_scaled[, c("Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)")] <-
data[, c("Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)")] / 1e6
# Log transformation
data_transformed <- data_scaled
data_transformed[, c("Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)",
"Real effective exchange rate index (2010 = 100)")] <-
log(data_scaled[, c("Debt service on external debt, total (TDS, current US$)",
"GDP (current US$)",
"Real effective exchange rate index (2010 = 100)")])
data_transformed <- as.data.frame(data_transformed)
colnames(data_transformed) <- c('Year','Debt', 'GDP', 'ExchangeRate')
head(data_transformed)
# Assign variables
y <- data_transformed$ExchangeRate
X <- as.matrix(data_transformed[, c("Debt", "GDP")])
# Summary of the data
summary(data_transformed)
# Create a subset for plotting
data_subset <- data_transformed[, c("ExchangeRate", "Debt", "GDP")]
# Create pair plot using GGally
ggpairs(data_subset,
title = "Scatter Plots of Exchange Rate and Predictors",
progress = FALSE)
source('Data Preparation.R')
# Preliminary model (OLS estimation) for informative prior ----------------
# Preliminary OLS model
ols_model <- lm(y ~ X)
summary(ols_model)
# Extract coefficients and residual variance
ols_coefficients <- coef(ols_model)
ols_variance <- var(residuals(ols_model))
# Priors for beta and mu
prior_mu <- ols_coefficients[1]  # Intercept
prior_beta <- ols_coefficients[-1]  # Coefficients for predictors
prior_variance <- ols_variance  # Prior variance for residuals
# Prior, Likelihood, and Posterior functions ------------------------------
# Defining Prior
log_prior <- function(params) {
mu <- params[1]
gamma <- params[2]
beta_X <- params[3:(2 + ncol(X))]
omega <- params[3 + ncol(X)]
alpha <- params[4 + ncol(X)]
beta <- params[5 + ncol(X)]
# Priors based on empirical evidence
prior_mu <- dnorm(mu, prior_mu, sqrt(prior_variance), log = TRUE)
prior_gamma <- dnorm(gamma, 0, 10, log = TRUE)
prior_beta_X <- sum(dnorm(beta_X, prior_beta, sqrt(prior_variance), log = TRUE))
prior_omega <- ifelse(omega > 0 & omega < 1, 0, -Inf)
prior_alpha <- ifelse(alpha > 0 & alpha < 1, 0, -Inf)
prior_beta <- ifelse(beta > 0 & beta < 1, 0, -Inf)
return(prior_mu + prior_gamma + prior_beta_X + prior_omega + prior_alpha + prior_beta)
}
# Defining log-likelihood function
log_likelihood <- function(params, y, X) {
mu <- params[1]
gamma <- params[2]
beta_X <- params[3:(2 + ncol(X))]
omega <- params[3 + ncol(X)]
alpha <- params[4 + ncol(X)]
beta <- params[5 + ncol(X)]
n <- length(y)
h <- numeric(n)
h[1] <- omega / (1 - alpha - beta)
log_lik <- 0
for (t in 2:n) {
h[t] <- omega + alpha * (y[t-1] - mu - gamma * h[t-1] - sum(X[t-1, ] * beta_X))^2 + beta * h[t-1]
log_lik <- log_lik - 0.5 * (log(2 * pi) + log(h[t]) + (y[t] - mu - gamma * h[t] - sum(X[t, ] * beta_X))^2 / h[t])
}
return(log_lik)
}
# Combining Prior and Likelihood for posterior
log_posterior <- function(params, y, X) {
# Extract parameters
beta_0 <- params[1]
beta_X <- params[2:(1 + ncol(X))]
omega <- params[2 + ncol(X)]
alpha <- params[3 + ncol(X)]
beta <- params[4 + ncol(X)]
# Compute the log-prior
log_prior <- 0
if (omega <= 0 || alpha <= 0 || beta <= 0 || (alpha + beta) >= 1) {
return(-Inf)  # Invalid GARCH parameters
}
log_prior <- sum(dnorm(beta_X, mean = 0, sd = 1, log = TRUE)) +
dgamma(omega, shape = 2, rate = 1, log = TRUE) +
dbeta(alpha, 2, 2, log = TRUE) +
dbeta(beta, 2, 2, log = TRUE)
# Compute the log-likelihood
n <- length(y)
h <- numeric(n)
h[1] <- var(y)  # Initialize variance
log_likelihood <- 0
for (t in 2:n) {
h[t] <- omega + alpha * (y[t - 1]^2) + beta * h[t - 1]
if (h[t] <= 0) {
return(-Inf)  # Invalid variance
}
mu_t <- beta_0 + sum(beta_X * X[t, ])
log_likelihood <- log_likelihood + dnorm(y[t], mean = mu_t, sd = sqrt(h[t]), log = TRUE)
}
# Total log-posterior
log_posterior_value <- log_prior + log_likelihood
# Debugging output
cat("Log Prior:", log_prior, "\n")
cat("Log Likelihood:", log_likelihood, "\n")
cat("Log Posterior:", log_posterior_value, "\n")
return(log_posterior_value)
}
source('Prior, Likelihood, and Posterior functions.R')
# Define the Metropolis algorithm
metropolis <- function(init, y, X, n_iter, proposal_sd) {
params <- init
samples <- matrix(NA, nrow = n_iter, ncol = length(init))
accept <- 0
for (i in 1:n_iter) {
proposal <- rnorm(length(init), mean = params, sd = proposal_sd)
log_accept_ratio <- log_posterior(proposal, y, X) - log_posterior(params, y, X)
# Debugging and safeguard
if (is.na(log_accept_ratio) || is.nan(log_accept_ratio)) {
cat("Invalid log_accept_ratio at iteration", i, "\n")
cat("Proposed Parameters:", proposal, "\n")
cat("Log Posterior (proposal):", log_posterior(proposal, y, X), "\n")
cat("Log Posterior (current):", log_posterior(params, y, X), "\n")
stop("log_accept_ratio is invalid. Check your log_posterior function.")
}
if (log(runif(1)) < log_accept_ratio) {
params <- proposal
accept <- accept + 1
}
samples[i, ] <- params
}
cat("Acceptance rate:", accept / n_iter, "\n")
return(samples)
}
# Initial values for parameters
init <- c(prior_mu, 0.1, rep(0.1, ncol(X)), 0.1, 0.1, 0.1)
# Run MCMC
n_iter <- 10000
proposal_sd <- 0.008
samples <- metropolis(init, y, X, n_iter, proposal_sd)
# Summarizing Results -----------------------------------------------------
# Posterior means and credible intervals
posterior_means <- colMeans(samples)
credible_intervals <- apply(samples, 2, quantile, probs = c(0.025, 0.975))
# Print results
cat("Posterior Means:\n", posterior_means, "\n")
cat("95% Credible Intervals:\n", credible_intervals, "\n")
# Plot posterior distributions
par(mfrow = c(3, 2))
for (i in 1:ncol(samples)) {
hist(samples[, i], main = paste("Parameter", i), xlab = "Value", probability = TRUE)
}
source('Implementing MCMC sampling.R')
# Convert samples matrix to mcmc object (for analysis with coda)
mcmc_samples <- as.mcmc(samples)
library(coda)
# Convert samples matrix to mcmc object (for analysis with coda)
mcmc_samples <- as.mcmc(samples)
# Plot trace plots for each parameter
par(mfrow=c(2, 2))  # Arrange the plots in a 2x2 grid
plot(mcmc_samples[, 1], main="Trace Plot: Parameter 1")
plot(mcmc_samples[, 2], main="Trace Plot: Parameter 2")
plot(mcmc_samples[, 3], main="Trace Plot: Parameter 3")
plot(mcmc_samples[, 4], main="Trace Plot: Parameter 4")
proposal_sd <- 0.01
samples <- metropolis(init, y, X, n_iter, proposal_sd)
# Posterior means and credible intervals
posterior_means <- colMeans(samples)
credible_intervals <- apply(samples, 2, quantile, probs = c(0.025, 0.975))
# Print results
cat("Posterior Means:\n", posterior_means, "\n")
cat("95% Credible Intervals:\n", credible_intervals, "\n")
# Plot posterior distributions
par(mfrow = c(3, 2))
for (i in 1:ncol(samples)) {
hist(samples[, i], main = paste("Parameter", i), xlab = "Value", probability = TRUE)
}
n_iter <- 5000
proposal_sd <- 0.01
samples <- metropolis(init, y, X, n_iter, proposal_sd)
# Posterior means and credible intervals
posterior_means <- colMeans(samples)
# Summarizing Results -----------------------------------------------------
# Posterior means and credible intervals
posterior_means <- colMeans(samples)
credible_intervals <- apply(samples, 2, quantile, probs = c(0.025, 0.975))
# Print results
cat("Posterior Means:\n", posterior_means, "\n")
cat("95% Credible Intervals:\n", credible_intervals, "\n")
# Plot posterior distributions
par(mfrow = c(3, 2))
for (i in 1:ncol(samples)) {
hist(samples[, i], main = paste("Parameter", i), xlab = "Value",
probability = TRUE)
}
library(coda)
# Convert samples matrix to mcmc object (for analysis with coda)
mcmc_samples <- as.mcmc(samples)
# Plot trace plots for each parameter
par(mfrow=c(2, 2))  # Arrange the plots in a 2x2 grid
plot(mcmc_samples[, 1], main="Trace Plot: Parameter 1")
plot(mcmc_samples[, 2], main="Trace Plot: Parameter 2")
plot(mcmc_samples[, 3], main="Trace Plot: Parameter 3")
plot(mcmc_samples[, 4], main="Trace Plot: Parameter 4")
plot(mcmc_samples[, 1], main="Trace Plot: Parameter 1")
plot(mcmc_samples[, 2], main="Trace Plot: Parameter 2")
plot(mcmc_samples[, 3], main="Trace Plot: Parameter 3")
plot(mcmc_samples[, 4], main="Trace Plot: Parameter 4")
for (i in 1:ncol(samples)) {
hist(samples[, i], main = paste("Parameter", i), xlab = "Value",
probability = TRUE)
}
